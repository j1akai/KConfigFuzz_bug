Bug 类型
​​释放后使用（Use-After-Free, UAF）​​ 导致的 ​​内存页错误（Page Fault）​​。

程序访问了已经被释放并可能被重用的内存区域。

触发条件与根本原因分析
调用栈和错误信息清晰地展示了问题发生的完整路径：

1.
​​触发操作（用户空间）​​：用户程序 syz-executor（Syzkaller 模糊测试工具）通过 sendto 系统调用发送了一个 Netlink 消息（rtnetlink），请求设置网络设备的 MAC 地址（dev_set_mac_address_user）。

2.
​​内核处理路径​​：

•
dev_set_mac_address -> call_netdevice_notifiers -> raw_notifier_call_chain
•
这触发了网络设备通知链，调用了 ndisc_netdev_event（IPv6 邻居发现协议的事件处理函数）。
•
ndisc_netdev_event 调用 neigh_changeaddr，该函数通知邻居子系统 MAC 地址发生了变化。
3.
​​致命操作​​：neigh_changeaddr 调用 neigh_flush_dev，其目的是刷新（删除）所有与指定网络设备相关的邻居表项（ARP/NDISC 缓存）。

4.
​​崩溃点​​：在 neigh_flush_dev 函数中（net/core/neighbour.c:395），代码试图遍历邻居哈希表并检查表项。​​导致崩溃的指令​​是：
cmp %r12, 0x308(%rbp) <-- trapping instruction

•
这里 %rbp 寄存器存储的是一个指向 neighbour 结构体的指针。
•
指令试图访问该结构体偏移 0x308 处的成员，并与 %r12 进行比较。
5.
​​根本原因​​：

•
从寄存器状态可以看到，​​%rbp 的值是 0x0000000100040048​​（RBP: 0000000100040048）。这是一个​​无效的、非规范的用户空间地址​​，而不是一个指向有效内核邻居结构体的指针。
•
这个无效指针表明，这个 neighbour 结构体​​已经被释放了​​，它所占用的内存已经被归还给系统，或者被其他数据覆盖（变成了垃圾值）。当内核后续试图访问这个已被释放的结构体时，就访问了无效地址 0x0000000100040350（0x0000000100040048 + 0x308），从而触发了页错误。
问题根源（UAF）
问题的本质是 ​​并发条件下的释放后使用​​：

1.
​​场景​​：在邻居子系统正在遍历和操作邻居表项（如刷新缓存）的同时，另一个内核线程（可能是软中断、RCU 回调或另一个 CPU 上的进程）​​并发地​​删除了某个邻居表项并释放了其内存。
2.
​​Syzkaller 的角色​​：Syzkaller 的模糊测试通过极端的并发压力（频繁地创建、销毁和配置网络设备及邻居信息）极大地提高了触发这种竞态条件的概率。
3.
​​结果​​：neigh_flush_dev 函数持有一个陈旧的指针，它认为该指针仍然指向一个有效的 neighbour 结构体，但实际上该内存早已被释放。当代码解引用这个“悬垂指针（dangling pointer）”时，系统就崩溃了。