Bug 类型
​​释放后使用（Use-After-Free, UAF）​​ 导致的 ​​内存页错误（Page Fault）​​。

这是一种高危内存安全漏洞，程序访问了已经被释放的内存区域。

触发条件与根本原因分析
这个 Bug 的触发过程分为两个阶段，从两个 Oops 可以清晰地看出问题的发展：

第一阶段 (#1 Oops)：检测到问题
1.
​​检测者​​：ksoftirqd/0（内核软中断守护进程）在执行 RCU 回调处理（rcu_core）时，准备释放页面（free_unref_page）。
2.
​​检测机制​​：在释放内存页之前，内核的 debugobjects 调试功能会调用 debug_check_no_obj_freed 来检查即将释放的内存范围内是否包含任何活跃的 debugobjects。这是一种用于检测 Use-After-Free 的防护机制。
3.
​​触发错误​​：在该检查函数中，代码试图遍历一个对象链表。​​关键指令​​是：
mov (%r12),%r12 <-- trapping instruction
此时 %r12 寄存器的值是 0x0000000200000001（见 R12: 0000000200000001）。这是一个​​无效的、非规范的用户空间地址​​。试图从这个地址读取内容必然导致页错误（#PF）。
4.
​​根本原因​​：%r12 本应是一个指向有效内核对象的指针，但它现在是一个垃圾值。这强烈表明​​这个指针所指向的内存对象已经被释放并重用了​​，它的内存内容被其他数据覆盖了。debugobjects 在检查时撞上了这个已被破坏的数据结构，从而触发了页错误。
第二阶段 (#2 Oops)：问题的根源
第二个 Oops 揭示了问题是如何发生的：

1.
​​执行路径​​：一个用户进程 syz.4.18965 通过 exit_group 系统调用退出，引发了进程地址空间的销毁（exit_mmap -> tlb_finish_mmu）。
2.
​​操作​​：在销毁过程中，内核使用 call_rcu() 异步释放一些资源。call_rcu() 会初始化一个 debugobject 来跟踪这个 RCU 回调。
3.
​​触发错误​​：在初始化 debugobject (debug_object_activate) 时，代码在 alloc_object 函数中试图写一个指针：
mov %rax, 0x8(%rax)
此时 %rax 的值是 0x0000000100040048（见 RAX: 0000000100040048）。这同样是一个​​无效的非规范地址​​。试图向 0x0000000100040050（0x0000000100040048 + 8）写入数据触发了第二个页错误。
4.
​​根本原因​​：用于存储 debugobject 的​​内存池（pool）本身已经损坏或被释放了​​。alloc_object 函数从一个本应是对象池指针的地方取到了一个垃圾值（0x0000000100040048），然后试图使用它，导致了崩溃。
综合分析
这是一个典型的 ​​元数据损坏（Metadata Corruption）​​。

•
​​根本原因​​：内核内存管理子系统中用于调试的 debugobjects 机制​​自身的数据结构被破坏了​​。这通常是由于某个其他的内核bug（如缓冲区溢出、错误的指针操作）覆盖了 debugobjects 池的内存。
•
​​直接原因​​：当后续的内核代码（无论是 ksoftirqd 还是退出进程）试图使用这些已被破坏的调试对象结构时，访问了无效的内存地址，从而触发页错误。
•
​​Syzkaller 的角色​​：Syzkaller 的模糊测试通过极端的并发压力（让进程频繁创建和退出）暴露了这个深层的内存管理缺陷。