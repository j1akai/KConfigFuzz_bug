​Bug 类型​​
​​1. 锁依赖检测失败（DEBUG_LOCKS_WARN_ON）​​

•
触发位置：kernel/locking/lockdep.c
•
根本原因：内核锁依赖检测器（lockdep）发现 ​​非法的锁获取顺序​​ 或 ​​锁上下文冲突​​（如在原子上下文中错误获取睡眠锁）。
​​2. 网络设备状态不一致​​

•
涉及多个子系统（bonding/bridge/batman-adv/hsr等）
•
表现：设备卸载时工作队列未正确同步，导致访问已释放资源。
​​触发条件​​
​​1. 直接触发路径​​
graph TD
    A[用户空间操作] --> B[关闭网络设备/命名空间]
    B --> C[调用驱动卸载函数]
    C --> D[清理工作队列/定时器]
    D --> E[锁依赖检测失败]
    D --> F[访问已释放资源]






​​2. 关键并发场景​​
触发操作	竞态点	后果
网络设备关闭	工作队列未完全取消	工作项访问已释放的net_device
蓝牙HCI命令超时	中断与工作队列竞争	内核警告或内存损坏
多网卡聚合（bonding）	从设备状态未同步	释放后使用（UAF）
​​根本原因​​
1.
​​锁顺序问题​​

•
在设备卸载路径中，rtnl_lock（网络设备锁）与其他锁（如工作队列锁）的获取顺序违反内核锁规则。
2.
​​生命周期管理缺陷​​

•
示例代码片段（问题逻辑）：
void netdev_unregister(struct net_device *dev) {
    cancel_work_sync(&dev->work); // 可能太晚！
    free(dev); // 工作队列可能仍在运行
}
3.
​​蓝牙与网络子系统交互​​

•
蓝牙命令（如hci_cmd_timeout）与网络设备清理并发时，共享资源未正确保护。