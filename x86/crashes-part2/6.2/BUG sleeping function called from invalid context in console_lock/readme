Bug 类型​​
​​非法上下文睡眠​​（Sleeping in Atomic Context）

•
​​违反规则​​：在原子上下文（不可睡眠）中调用了可能睡眠的函数 console_lock()
•
​​危险等级​​：高（可能导致系统死锁或崩溃）
​​触发条件​​
​​关键要素​​
1.
​​执行上下文​​：

•
in_atomic(): 1（原子上下文）
•
irqs_disabled(): 1（中断关闭）
•
preempt_count: 1（禁止抢占）
•
进程：syz.2.15224（Syzkaller模糊测试进程）
2.
​​调用路径​​：

graph TD
    A[gsmld_write] --> B[con_write]
    B --> C[do_con_write]
    C --> D[console_lock]




3.
​​冲突点​​：

•
console_lock() 内部会调用 might_sleep()，但当前上下文不允许睡眠
​​根本原因​​
​​代码层面​​
// drivers/tty/n_gsm.c
void gsmld_write() {
    // 在原子上下文中调用终端写入
    con_write(); // --> 最终调用 console_lock()
}

// kernel/printk/printk.c
void console_lock() {
    might_sleep(); // 此处触发警告
    down(&console_sem); // 可能睡眠的互斥锁
}
​​设计问题​​
1.
​​GSM Line Discipline驱动​​（n_gsm.c）错误地假设其写入操作可以在原子上下文中执行
2.
​​终端子系统​​（vt层）未对调用者上下文做严格校验
​​错误影响​​
影响范围	后果
系统稳定性	可能引发内核死锁或Oops
GSM模块功能	数据写入失败
调试系统	printk输出可能丢失